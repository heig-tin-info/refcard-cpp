\documentclass{article}
\usepackage[a4paper, landscape, margin=0.5cm]{geometry}
\usepackage[fontsize=6.5pt]{scrextend}
\usepackage{fontspec}
\usepackage[french]{babel}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{stix}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage[newfloat]{minted}

\input{revision}

\ifdefined\tinted
  \pagecolor{ProcessBlue!30}
\fi

\setlength{\columnsep}{5mm}
\setlength{\columnseprule}{0.4pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{2pt}

\renewcommand{\familydefault}{\sfdefault}

\usemintedstyle{bw}

\newminted{cpp}{
  fontsize=\footnotesize,
  breaklines=true,
  autogobble=true,
  linenos=false,        % passe à true si tu veux des numéros de ligne
  tabsize=3,
  mathescape,
}

\setmonofont{Source Code Pro}

% Configuration
\renewcommand{\familydefault}{\sfdefault}

\titleformat{\section}
  {\sffamily\bfseries\fontsize{12}{15}\selectfont} % ajoute  si tu veux en gras
  {}{0pt}{}

\titleformat{\subsection}
  {\sffamily\bfseries\fontsize{9}{11}\selectfont}
  {}{0pt}{}

\titleformat{\subsubsection}
  {\sffamily\bfseries\fontsize{8}{10}\selectfont}
  {}{0pt}{}

% Espacements (les tiens, inchangés)
\titlespacing*{\section}{0pt}{0ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}
\titlespacing*{\subsection}{0pt}{0.1ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}
\titlespacing*{\subsubsection}{0pt}{0.1ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}

% No pages numbering
\pagenumbering{gobble}

\newlength\mybaselinestretch
\mybaselinestretch=0pt plus 0.02pt\relax
\addtolength{\baselineskip}{\mybaselinestretch}

\setlength\parindent{0pt}
\setlength\tabcolsep{1.5pt}
\setlength{\columnseprule}{0.4pt}

% Macros
\newcommand{\tab}{\hspace{2em}}
\newcommand{\etc}{\small \ldots}
\newcommand{\any}{$\hzigzag$~}
\newcommand{\spc}{$\mathvisiblespace$}
%\newcommand{\cd}{\lstinline}
\newcommand{\cd}[1]{\mintinline{cpp}{#1}}

\begin{document}
\raggedcolumns
\begin{multicols*}{4}
\raggedbottom

\begin{tabularx}{\columnwidth}{llX}
    \raisebox{-\totalheight}{\includegraphics[width=1cm]{assets/heig-vd-black.pdf}} & \raisebox{-\totalheight}{\includegraphics[width=0.7cm]{assets/cpp-lang.pdf}} &
    \begin{center}
      {\Large \bf Carte de référence C++} \\
      HEIG-VD -- version \revision \ -- \revisiondate \\
    \end{center}
\end{tabularx}

    Cette carte de référence peut être utilisée durant les travaux écrits et examens
    des cours \emph{progoo} et \emph{progoox} à moins que le contraire soit explicitement formulé.
    Elle est une liste non exhaustive des possibilités du langage C++ et un complément à la carte de référence du langage C.

\section*{Différences C/C++}
\begin{cppcode}
void func();         // n'accepte aucun argument
int *ip = nullptr;   // Utiliser à la place de NULL
#include <cstdio>    // Au lieu de <stdio.h> (pas de .h)
struct { int a; } s = { .a=42 }; // Non portable C++
\end{cppcode}

\section*{Généralités et spécificités}

\begin{cppcode}
// Surcharge de fonctions
void say(char const* s) { printf("%s\n", s); }
void say(int u) { printf("%d\n", u); }
int main() { say("Hello"); say(15); } // Selon type

// Arguments par défaut
void foo(int a = 1, int b = 4) { ... }
int main() { foo();     // a = 1, b = 4
              foo(20); } // a = 20, b = 4

for(auto x : iterable)  // x est une copie
for(auto& x : iterable) // x est une référence

// Initializer lists
std::vector<int> v{1, 2, 3, 4, 5};
std::map<std::string, int> m{{"a", 1}, {"b", 2}};

// Uniform initialization
int x{42};
std::string s{"Hello"};

// Decltype et auto
int x = 42;
decltype(x) z = 10; // Extrait le type de x (ici int)
auto y = 3.14;      // Type déduit (ici double)

// Constexpr (évaluation à la compilation)
constexpr int square(int x) { return x * x; }
int arr[square(5)]; // Taille connue à la compilation
constexpr double pi = 3.14159265358979323846;

// Likely/Unlikely (C++20)
if (x > 0) [[likely]] { ... } else [[unlikely]] { ... }
// C++23 style (plus concis)
if (likely(x > 0)) { ... } else { ... }

// Assert (debug uniquement)
static_assert(sizeof(int) == 4, "int doit faire 4 bytes");
static_assert(std::is_integral_v<int>);
\end{cppcode}

\section*{Chaînes de caractère}

\begin{cppcode}
#include <string>

string a = "Hello", b = "World";
cout << a + " " + b; // "Hello World"
cout << a + " You"; // "Hello You"
a.append(" Dog"); // En C++ les chaînes sont modifiables
auto raw = R"(Path: C:\Users\Name\File.txt)";
auto multiline = R"delimiter(
   ...
)delimiter"; // Multiligne
\end{cppcode}

\section*{Références}

\begin{cppcode}
string foo = "foo";
string& fooRef = foo;    // Référence sur foo
fooRef += "bar";         // Modifie foo via la référence
cout << foo;             // Affiche "foobar"
cout << &fooRef << endl; // Affiche l'adresse de foo
fooRef = string("bar");  // Copie de la valeur dans foo

const string& cbarRef = foo;
cbarRef += ". Hi!";       // Erreur ! cbarRef est const

string str;
void func(string& s) { ... }  // Référence lvalue
void func(string&& s) { ... } // Référence rvalue
func(str);                    // Référence lvalue
func(foo());                  // Référence rvalue
\end{cppcode}

\section*{Flux / Streams}
\begin{cppcode}
// Include <iostream>, <iomanip>
int i;
cin >> i;  // Lecture
cout << "Number: " << i << "\n";         // Format
cerr << "An error message" << endl;      // Stderr
double x = 3.141592;
cout << std::fixed; // Format décimal fixe
cout.precision(2);  // 2 chiffres après la virgule
cout << x << endl;  // Affiche 3.14
cout << std::scientific; // Format scientifique (3.14e+00)
cout << std::setw(5) << std::setprecision(3) << x; // %5.3f
cout << std::endl;  // Retour à la ligne + flush
\end{cppcode}

\section*{Enumérations}

\begin{cppcode}
// Enumérations non typées
enum AnimalTypes { Mammals, Birds, Reptiles, Fish };
AnimalTypes GetAnimalType() { return Reptiles; }

// Enumérations typées (cast implicite en uint8)
enum Amphibians : uint8_t { Frogs, Toads=2 };

// Enum fortement typées (pas de cast implicite)
enum class Birds : uint8_t { Chickens, Ducks };
\end{cppcode}

\section*{Templates}

\begin{cppcode}
template <class T> T f(T t);  // Template à 1 paramètre T
template <class T> class X {  // Classe avec paramètre T
   X(T t); };                 // Constructeur
template <class T>
   X<T>::X(T t) {}            // Impl. du constructeur
X<int> x{3};                  // Un objet de type X de int
template <class T, class U=T> // Valeurs par défaut

Box<Box<int> > boxOfBox;  // Template imbriquées
                          // Espace après > requis en C++03

template<int Y=23> void p() { // Paramètre scalaire
   cout << "You said " << Y; }// Affiche "You said 23"

template<>                    // Spécialisation
void p<42>() {                // (implémentation spécifique
   cout << "The Answer!\n"; } //  pour la valeur 42)
p<12>(); // You said 12
p<42>(); // The Answer!
\end{cppcode}

    \section*{Namespaces}

    \begin{cppcode}
extern "C" { void f(); }    // Si f() compilé dans un obj C
namespace N { class T {}; } // Cache la classe T dans N
N::T t;                     // Accès avec opérateur ::
using namespace N;          // Rend T visible sans préfixe
using namespace std;        // Pour éviter std::xxx
\end{cppcode}

\section*{Classes}
\begin{cppcode}
struct S { int x; }; // Membres public par défaut
class  C { int x; }; // Membres privé par défaut

class Foo; // Déclaration anticipée

// Membres par défaut
struct A {
  A();                    // 1. Constructeur par défaut
  A(const A&);            // 2. Constructeur de copie
  A& operator=(const A&); // 3. Opérateur d'assignation
  A(A&&);                 // 4. Constructeur de déplacement
  A& operator=(A&&);      // 5. Opérateur de déplacement
  ~A();                   // 6. Destructeur
}; // Point virgule obligatoire

// Rule-of-three: 2, 3, 6
// Rule-of-five: 2, 3, 4, 5, 6

class Dog {
    std::string name; // Privé par défaut (private:)
    int weight = 0; // Initialisation par défaut (C++11)
    mutable int age = 0; // Modifiable même si const
    std::vector<std::string> nicknames;
public:
    Dog(); // Constructeur par défaut
    // Constructeur avec members initializer list
    Dog(std::string n, int w=0) : name{n}, weight(w) {}
    // Constructeur avec liste d'initialisation
    Dog(std::initializer_list<std::string> nicks)
        : nicknames(nicks), age(0) {}
    void setName(const std::string& dogsName);
    void setWeight(int dogsWeight);
    void print() const; // const: ne modifie pas l'objet
    // Méthode définie dans le body d'une classe
    void bark() const { std::cout << name << " barks!" << endl; }
}; // Ne pas oublier le point-virgule!

// Implémentation externe des méthodes
Dog::Dog() {
    std::cout << "A dog has been constructed\n";
}

class C {
    C() = default; // Constructeur par défaut
    C(const C&) = delete; // Interdit la copie
    virtual ~C() = default; // Destructeur virtuel
    void f() const; // Méthode constante
    static int count; // Attribut statique (partagé)
    static int getCount(); // Méthode statique
};
\end{cppcode}

\section*{Interfaces}
\begin{cppcode}
// Interface = uniquement des méthodes virtuelles pures
class Shape {
    // Normalement pas d'attributs dans une interface
    virtual double area() const = 0;
    virtual ~Shape() = default;
};
\end{cppcode}

\section*{Héritage et polymorphisme}
\begin{cppcode}
class Triangle : public Shape { // Héritage public
    double base, height;
public:
    Triangle(double b, double h)
        : base(b), height(h) {}
    double area() const override { // Override
        return 0.5 * base * height; }
};
class Bar : public Foo {
    using Foo::Foo; }; // Hérite des constructeurs

void D::m() const {
    C::m(); } // Appel de la méthode du parent
\end{cppcode}

\section*{Polymorphisme}

\begin{cppcode}
// Surcharge d'opérateurs
T operator+(T x, T y);  // Surcharge +
T operator-(T x);       // Surcharge -x
T operator++(int);      // Surcharge x++ (postfixe)
T& operator++();        // Surcharge ++x (préfixe)
auto operator<=>(const P&) const = default;  // C++20 spaceship

// Opérateurs de comparaison
bool operator==(const T& other) const;
bool operator!=(const T& other) const;
bool operator<(const T& other) const;

// Opérateurs d'accès
T& operator[](size_t index);              // Accès par index
const T& operator[](size_t index) const;
T& operator*();                           // Déréférencement
T* operator->();                          // Accès membre

// Opérateurs d'assignation
T& operator+=(const T& other);
T& operator-=(const T& other);
T& operator*=(const T& other);
T& operator/=(const T& other);

// Surcharge de flux
template <class T>
std::ostream& operator<<(std::ostream& os, const T& t) {
    os << t.member; return os; }
\end{cppcode}

\section*{Exceptions}

\begin{cppcode}
// inclure <stdexcept>, <exception>
try {
   throw std::runtime_error("A problem occured"); }
catch (const std::exception& ex) {
   std::cout << ex.what(); }
catch (...) {
   std::cout << "Unknown exception caught";
   throw; } // Relève l'exception

// Spécification noexcept
void safe_function() noexcept;          // Ne lance jamais
void conditional() noexcept(condition); // Conditionnel
\end{cppcode}

\section*{Conteneurs de données}

\subsection*{Vector}
Tableau dynamique: capacité augmente de façon amortie (impl.-dépendant).
\begin{cppcode}
#include <vector>

vector<string> v;
v.push_back("item"); // Ajoute à la fin
v.back();        // Dernier élément
v.pop_back();    // Enlève à la fin
v.front();       // Premier élément
v[0];            // Accès direct (non sécurisé)
v.at(1);         // Accès sécurisé (vérifie les bornes)
v.clear();       // Vide le vecteur
v.insert(v.end(), 42); // Insertion à la fin O(1)
v.insert(v.begin(), 42); // Insertion au début O(n)
v.erase(v.begin()); // Efface une position O(n)
v.erase(v.begin(), v.begin() + 2); // Efface un intervalle O(n)
v.empty() // Vrai si vide
v.size()  // Nombre d'éléments

vector<int> w(10, 42); // 10 éléments initialisés à 42
v.reserve(100); // Réserve de la place pour 100 éléments
v.resize(50);  // Redimensionne à 50 éléments (ajoute des zéros)

// Pour stocker des références
std::vector<std::reference_wrapper<int>> v;
int a=1, b=2; v.push_back(a); v.push_back(b);
\end{cppcode}

\subsection*{Tuples (Liste non-modifiable)}

\begin{cppcode}
#include <tuple>

tuple<int, char> x = make_tuple(10, 'A'); // auto accepté

get<0>(x) = 20; // Modifie le premier élément
char w = get<1>(x); // Copie le deuxième élément

int i, c;
tie(i, c) = x; // Unpacking

tuple<int, char, double> z(11, 'A', 3.1415);
auto size = tuple_size<decltype(z)>::value;

auto concatenated = tuple_cat(x, z);
\end{cppcode}

\subsection*{Map (Association clé-valeur)}
Unordered map implémenté avec une table de hachage (O(1))\\
Map implémenté avec un arbre binaire équilibré (log n)
\begin{cppcode}
#include <map>

map<char, int> m;
m.insert(pair<char,int>('A', 1)); // m['A'] = 1; possible
m.insert(pair<char,int>('Z', 26));

map<char, int>::iterator it; // Itérateur
for (it=m.begin(); it!=m.end(); ++it)
    std::cout << it->first << "->" << it->second << ", ";

it = m.find('Z');
cout << it->second; // Affiche 26

#include <unordered_map>
unordered_map<char, int> um;
um['A'] = 1; um['Z'] = 26;
\end{cppcode}

\subsection*{Set (Ensemble de valeurs uniques)}

\begin{cppcode}
#include <set>
set<int> s;
s.insert(4);
s.insert(15);
s.erase(8);

set<int>::iterator it;
for(it=s.begin(); it!=s.end(); it++) {
    cout << *it << endl; }
s.clear();
cout << s.size(); // Affiche zéro
\end{cppcode}

\section*{Algorithmes STL essentiels}

\begin{cppcode}
#include <algorithm>
#include <numeric>

std::vector<int> v{3, 1, 4, 1, 5};

std::sort(v.begin(), v.end()); // Tri croissant
std::reverse(v.begin(), v.end()); // Tri décroissant

// Recherche
auto it = std::find(v.begin(), v.end(), 4);
bool found = (it != v.end());
// Transformation
std::vector<int> v2(v.size());
std::transform(v.begin(), v.end(), v2.begin(),
               [](int x) { return x * 2; });
// Réduction
// Type retour celui de valeur initiale (ici int)
auto sum = std::accumulate(v.begin(), v.end(), 0);
// Filtrage (C++20 style avec remove_if)
v.erase(std::remove_if(v.begin(), v.end(),
                       [](int x) { return x % 2 == 0; }),
        v.end());
// Autres algorithmes utiles
auto min_it = std::min_element(v.begin(), v.end());
auto max_it = std::max_element(v.begin(), v.end());
std::swap(*min_it, *max_it);

bool all_positive = std::all_of(v.begin(), v.end(),
                        [](int x) { return x > 0; });
bool any_negative = std::any_of(v.begin(), v.end(),
                        [](int x) { return x < 0; });

std::vector<int> v3;
std::copy_if(v.begin(), v.end(), std::back_inserter(v3),
    [](int x) { return x % 2 == 0; }); // Copie condit.
\end{cppcode}

\section*{Fonctions anonymes (lambda)}

\begin{cppcode}

vector<pair<int, int> > v{{1,2}, {3,4}, {5,6}};
sort(
    v.begin(), v.end(),
    [](const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second < rhs.second; });

// Format: [captures](params) -> ret { body }
int x = 5; int y = 10;
auto g = [x, &y](int z) -> int { return x + y++ + z; };

// Formats de capture
[&]{}; [=]{}; // 1. Tout par référence, 2. tout par valeur
[&, i]{}; // Scope local par référence, i par valeur
[&, &i]{}; // Erreur, incohérent
[this]{};   // Cette instance par référence
[*this]{}; // Cette instance par valeur (copie)
\end{cppcode}

\section*{Tokens alternatifs}
\begin{cppcode}
true and false     // Conjonction logique
true or false      // Disjonction logique
not true           // Négation logique
compl 4            // Complément bit à bit
4 bitor 3          // Disjonction bit à bit
4 bitand 3         // Conjonction bit à bit
4 xor 3            // Disjonction exclusive bit à bit
\end{cppcode}

\section*{Smart Pointer}
\begin{cppcode}
#include <memory>

std::shared_ptr<Dog> doggo(new Dog()); // Ancien style
auto doggo = std::make_shared<Dog>();  // Préféré
doggo->bark();
// Pas besoin de supprimer le Dog, destruction auto

// Propriété exclusive
std::unique_ptr<Dog> dog = std::make_unique<Dog>();
// Transfert de propriété
std::unique_ptr<Dog> dog2 = std::move(dog);
// Référence faible (évite cycles)
// Utilisé comme observateur non possédant
std::weak_ptr<Dog> weak_dog = doggo;
if (auto strong_dog = weak_dog.lock())
    strong_dog->bark(); // Utilisation sécurisée
\end{cppcode}

\section*{Gestion mémoire et RAII}
\begin{cppcode}
// RAII (Resource Acquisition Is Initialization)
class FileHandler {
    FILE* file;
public:
    FileHandler(const char* name) : file(fopen(name, "r")) {
        if (!file) throw std::runtime_error("Cannot open file");
    }
    ~FileHandler() { if (file) fclose(file); } // Cleanup automatique
    FILE* get() { return file; }
};

// Allocation/désallocation manuelle (éviter si possible)
int* ptr = new int(42);        // Allocation
delete ptr;                    // Désallocation
int* arr = new int[10];        // Tableau
delete[] arr;                  // Désallocation tableau

// Préférer les containers et smart pointers
std::vector<int> v(10, 42);    // Gestion automatique
auto ptr = std::make_unique<int>(42); // Smart pointer
\end{cppcode}

\section*{Move semantics}

\begin{cppcode}
std::vector<int> v1 = {1,2,3,4,5};
std::vector<int> v2 = v1; // Copie (lent)
std::vector<int> v3 = std::move(v1); // Transfert (rapide)

class C {
    using value_type = std::string;
    C(value_type s) : data(s) {}
    C(C&& other) noexcept
        : data(std::move(other.data)) {}
    C& operator=(C&& other) noexcept {
        data = std::move(other.data);
        return *this; }
private:
    value_type data;
};
C a("X");
C b = std::move(a); // Construction par déplacement
b = std::move(a);   // Assignation par déplacement
\end{cppcode}

\section*{Ranges (C++20)}

\begin{cppcode}
// Inclure <ranges>, <vector>, <algorithm>, <iostream>
std::vector<int> v{1,2,3,4,5,6,7,8,9,10};

// Pipeline ranges: filtre puis transforme
auto rng = v
    | std::views::filter([](int x){ return x % 2 == 0; })
    | std::views::transform([](int x){ return x * x; });

for (int x : rng) std::cout << x << ' '; // 4 16 36 64 100

// Prise de tête zéro : lazy, pas de copies inutiles
auto first3 = rng | std::views::take(3);
auto rev    = rng | std::views::reverse;

// Conversion en conteneur:
std::vector<int> out;
std::ranges::copy(rng, std::back_inserter(out));
\end{cppcode}

\section*{Slices et Vues (C++20)}

\begin{cppcode}
// Inclure <span>, <string_view>, <vector>
// std::span : vue non-propriétaire sur un bloc contigu
// (T[], vector<T>, array<T,N>) n'alloue pas,
// ne possède pas, "slice" sans copie.
void sum_all(std::span<const int> s) {
    long long sum = 0;
    for (int x : s) sum += x; /* ... */ }

std::vector<int> v{1,2,3,4,5};
sum_all(v);              // conversion implicite vers span
sum_all(std::span{v}.subspan(1,3)); // slice [2,3,4]

// std::string_view : vue en lecture seule sur une chaîne
void print_sv(std::string_view sv) { /* pas de copie */ }

std::string s = "hello world";
print_sv(s); print_sv("abc"); // littéral → string_view
print_sv(std::string_view{s}.substr(6, 5)); // "world"
\end{cppcode}

\section*{Traits et Concepts (C++20)}

\begin{cppcode}
// Inclure <type_traits>, <concepts>, <vector>, <list>

// Traits classiques (C++11/14/17)
static_assert(std::is_integral_v<int>);
static_assert(!std::is_pointer_v<int>);

// Concepts standards
template<std::integral T>
T add(T a, T b) { return a + b; }

// Concept personnalisé
template<typename T>
concept HasSize = requires(T t) {
    { t.size() } -> std::convertible_to<std::size_t>;
};

template<HasSize C>
auto size2(const C& c) { return c.size() * 2; }

static_assert(std::ranges::range<std::vector<int>>);
static_assert(!std::ranges::range<int>);
\end{cppcode}

\section*{RTTI}

\begin{cppcode}
// Include <typeinfo>, <typeindex>
struct B {}; struct C : B { void f() { cout << "C"; } };
Base* pc = new C; // Allocation dynamique
// Vers pointeur : nullptr si échec
if (auto pd = dynamic_cast<C*>(pc)) { pd->f(); }
else { /* cast impossible */ }
// Vers référence : lève std::bad_cast si échec
try { C& rd = dynamic_cast<C&>(*pc); rd.f(); }
catch (const std::bad_cast& e) { ... e.what(); }
// Sur *p ou une référence de base polymorphe -> type dyn.
const std::type_info& ti_dyn = typeid(pc); // "C" dynam.
std::cout << ti_dyn.name() << '\n'; // Nom impl.-dépendant
if (typeid(pc) == typeid(Der)) { / ... */ } // Comp. Type.
// Stocker des types comme clés
std::unordered_map<std::type_index, std::string> names;
names.emplace(std::type_index(typeid(Der)), "Derived");
std::cout << names.at(typeid(Der)) << '\n';
\end{cppcode}

\section*{Divers}

\begin{cppcode}
// C++17: structured bindings
auto [key, value] = std::make_pair("hello", 42);
std::map<std::string, int> m{{"a", 1}, {"b", 2}};
for (const auto& [k, v] : m) {
    std::cout << k << ": " << v << "\n";
}

// if constexpr (C++17) évaluation à la compilation
template<typename T>
void process(T value) {
    if constexpr (std::is_integral_v<T>) {} else {} }

// Using declarations et alias
using std::cout, std::endl; // Import sélectif (C++17)
using vec_int = std::vector<int>; // Alias de type
template<typename T>
using vec = std::vector<T>; // Template alias

// Attribute (C++11/14/17/20)
[[nodiscard]] int important(); // Résultat pas ignorer
[[maybe_unused]] int x = 42;   // Variable potentiellement inutilisée
[[deprecated("Use new_function()")]] void old_function();
[[fallthrough]]; // Dans un switch, chute intentionnelle
\end{cppcode}

% \section*{Thread safety et concurrence}
% \begin{cppcode}
% #include <thread>
% #include <mutex>
% #include <atomic>

% // Threads
% std::thread t1([]{ std::cout << "Hello from thread\n"; });
% t1.join(); // Attendre la fin du thread

% // Mutex pour synchronisation
% std::mutex mtx;
% void safe_function() {
%     std::lock_guard<std::mutex> lock(mtx); // RAII lock
%     // Code thread-safe
% }

% // Atomic pour opérations atomiques
% std::atomic<int> counter{0};
% counter++; // Thread-safe

% // std::condition_variable pour synchronisation avancée
% std::mutex mtx;
% std::condition_variable cv;
% bool ready = false;

% void worker() {
%     std::unique_lock<std::mutex> lock(mtx);
%     cv.wait(lock, []{ return ready; }); // Attendre signal
%     // Travail...
% }

% void notifier() {
%     {
%         std::lock_guard<std::mutex> lock(mtx);
%         ready = true;
%     }
%     cv.notify_one(); // Réveiller un thread
% }

% // std::future pour résultats asynchrones
% std::future<int> result = std::async(std::launch::async, [](){
%     return 42;
% });
% int value = result.get(); // Récupérer le résultat
% \end{cppcode}

\section*{Utilitaires modernes}

\begin{cppcode}
// <optional> (C++17)
std::optional<int> parse_int(std::string_view s);
if (auto v = parse_int("42")) { /* v.value() */ }

// <variant> (somme de types)
std::variant<int, std::string> u = 42;
u = std::string{"hi"};

// <filesystem> (C++17)
namespace fs = std::filesystem;
for (auto& p : fs::directory_iterator(".")) {
    if (p.is_regular_file()) std::cout << p.path() << '\n';
}
// <chrono> (durées & time points)
using namespace std::chrono_literals;
auto t = 150ms + 2s;

// <format> (C++20) <print> (C++23)
std::string s = std::format("Hello {}, value = {}", "world", 42);
std::print("Pi ~ {:.3f}\n", 3.14159); // C++23

// <expected> (C++23) - gestion d'erreurs sans exceptions
std::expected<int, std::string> divide(int a, int b) {
    if (b == 0) return std::unexpected("Division by zero");
    return a / b;
}
auto result = divide(10, 2);
if (result) std::cout << *result; // 5
else std::cout << result.error(); // message d'erreur

// Coroutines (C++20) - exemple simple
std::generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a; auto next = a + b;
        a = b; b = next; } }
\end{cppcode}

% \section*{Étrangetés}

% \begin{cppcode}
% // Surcharge de méthode privées
% class Foo {
% private:
%    virtual void bar();
% };
% class FooSub : public Foo {
%    virtual void bar() override;      // Surcharge Foo::bar!
% };
%\end{cppcode}

% \section*{Optimisation}
% \begin{cppcode}
% // Objets temporaires
% string foo() { return string("foo"); }
% string retVal = foo(); // Choix selon optimisation:
% // 1. Copie inutile d'un objet temporaire (< C++11)
% // 2. Copy elision, suppression de la copie (C++17)
% // 3. Utilisation de move semantics si disponible

% return std::string("hello") // RVO (Return Value Optim.)
% return result; // NRVO (Named Return Value Optimization)

% // Conseils de performance
% // 1. Préférer ++i à i++ pour les itérateurs
% for (auto it = v.begin(); it != v.end(); ++it) { /* ... */ }

% // 2. Utiliser const& pour éviter les copies
% void process(const std::vector<int>& v); // Pas de copie

% // 3. Réserver la mémoire si taille connue
% std::vector<int> v;
% v.reserve(1000); // Évite les réallocations

% // 4. Utiliser emplace au lieu de push
% v.emplace_back(args...); // Construction in-place
% // au lieu de v.push_back(Type(args...));

% // 5. Move pour les ressources coûteuses
% std::vector<int> v1 = create_big_vector();
% std::vector<int> v2 = std::move(v1); // Pas de copie
% \end{cppcode}

% \section*{S.O.L.I.D.}
% \begin{description}
%     \item[S] Single responsibility principle
%     \item[O] Open for extension, closed for modification
%     \item[L] Liskov substition principle
%     \item[I] Interface segregation principle
%     \item[D] Dependency inversion principle
% \end{description}

\end{multicols*}
\end{document}
