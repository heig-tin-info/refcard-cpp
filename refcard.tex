\documentclass{article}
\usepackage[a4paper, landscape, margin=0.5cm]{geometry}
\usepackage[fontsize=6.5pt]{scrextend}
\usepackage{fontspec}
\usepackage[french]{babel}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{stix}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{multirow}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage[newfloat]{minted}

\input{revision}

\ifdefined\tinted
  \pagecolor{ProcessBlue!30}
\fi

\setlength{\columnsep}{5mm}
\setlength{\columnseprule}{0.4pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{2pt}

\renewcommand{\familydefault}{\sfdefault}

\usemintedstyle{trac}

\newminted{cpp}{
  fontsize=\footnotesize,
  breaklines=true,
  autogobble=true,
  linenos=false,        % passe à true si tu veux des numéros de ligne
  tabsize=3,
  mathescape,
}

\setmonofont{Source Code Pro}

% Configuration
\renewcommand{\familydefault}{\sfdefault}

\titleformat{\section}
  {\sffamily\bfseries\fontsize{12}{15}\selectfont} % ajoute  si tu veux en gras
  {}{0pt}{}

\titleformat{\subsection}
  {\sffamily\bfseries\fontsize{9}{11}\selectfont}
  {}{0pt}{}

\titleformat{\subsubsection}
  {\sffamily\bfseries\fontsize{8}{10}\selectfont}
  {}{0pt}{}

% Espacements (les tiens, inchangés)
\titlespacing*{\section}{0pt}{0ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}
\titlespacing*{\subsection}{0pt}{0.1ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}
\titlespacing*{\subsubsection}{0pt}{0.1ex plus .1ex minus 0.5ex}{0.5ex plus .1ex minus 0.2ex}

% No pages numbering
\pagenumbering{gobble}

\newlength\mybaselinestretch
\mybaselinestretch=0pt plus 0.02pt\relax
\addtolength{\baselineskip}{\mybaselinestretch}

\setlength\parindent{0pt}
\setlength\tabcolsep{1.5pt}
\setlength{\columnseprule}{0.4pt}

% Macros
\newcommand{\tab}{\hspace{2em}}
\newcommand{\etc}{\small \ldots}
\newcommand{\any}{$\hzigzag$~}
\newcommand{\spc}{$\mathvisiblespace$}
%\newcommand{\cd}{\lstinline}
\newcommand{\cd}[1]{\mintinline{cpp}{#1}}

\begin{document}
\raggedcolumns
\begin{multicols*}{4}
    \raggedbottom
    \begin{tabularx}{\columnwidth}{lX}
        \raisebox{-\totalheight}{\includegraphics[width=1cm]{assets/heig-vd-black.pdf}} &
        \begin{center}
            {\Large \bf Carte de référence C++11/C++23} \\
            version \revision \ -- \revisiondate \\
        \end{center}
    \end{tabularx}

    Cette carte de référence peut être utilisée durant les travaux écrits et examens
    des cours \emph{progoo} et \emph{progoox} à moins que le contraire soit explicitement formulé.
    Elle est une liste non exhaustive des possibilités du langage C++ et un complément à la carte de référence du langage C.
    Ce travail est inspiré de \emph{Learn X in Y} et de la carte de référence de Matt Mahoney.
    Ci-dessous, la signification des termes utilisés dans cette carte de référence.

    \begin{tabularx}{\linewidth}{
            >{\hsize=0.4\hsize}X% 10% of 4\hsize
            >{\hsize=1.5\hsize}X% 30% of 4\hsize
            >{\hsize=0.4\hsize}X% 30% of 4\hsize
            >{\hsize=1.5\hsize}X% 30% of 4\hsize
            % sum=4.0\hsize for 4 columns
        }

        \tt \etc      & Continuation logique      & \tt \any  & N'importe quoi \\
        \tt /\any/    & Expression régulière      & \tt \spc  & Espace obligatoire           \\
        \cd{type}     & \tt int, long, float... & \cd{name} & \tt /[A-Za-z][A-Za-z0-9\_]+/ \\
        \cd{value}    & Valeur                    & \cd{NAME} & \tt /[A-Z][A-Z0-9\_]+/       \\
        \cd{fname} & Chemin de fichier relatif & \cd{expr} & e.g. \tt a + b               \\
    \end{tabularx}
    \hrule

    \section*{Différences C/C++}
    \begin{cppcode}
void func();         // n'accepte aucun argument
int *ip = nullptr;   // Utiliser à la place de NULL
#include <cstdio>    // Au lieu de <stdio.h> (pas de .h)
\end{cppcode}

\section*{Généralités et spécificités}

\begin{cppcode}
// Surcharge de fonctions
void say(char const* s) { printf("%s\n", s); }
void say(int u) { printf("%d\n", u); }
int main() { say("Hello"); say(15); } // Selon type

// Arguments par défaut
void foo(int a = 1, int b = 4) { ... }
int main() { foo();     // a = 1, b = 4
              foo(20); } // a = 20, b = 4

for(auto x : iterable)  // x est une copie
for(auto& x : iterable) // x est une référence

// Initializer lists
std::vector<int> v{1, 2, 3, 4, 5};
std::map<std::string, int> m{{"a", 1}, {"b", 2}};

// Uniform initialization
int x{42};
std::string s{"Hello"};

// Decltype et auto
int x = 42;
decltype(x) z = 10; // Extrait le type de x (ici int)
auto y = 3.14;      // Type déduit (ici double)

// Constexpr (évaluation à la compilation)
constexpr int square(int x) { return x * x; }
int arr[square(5)]; // Taille connue à la compilation
constexpr double pi = 3.14159265358979323846;

// Likely/Unlikely (C++20)
if (x > 0) [[likely]] { ... } else [[unlikely]] { ... }
if (likely(x > 0)) { ... } else { ... } // C++23
\end{cppcode}
\section*{Entrées sorties (streams)}

\begin{cppcode}
#include <iostream>
using namespace std; // Évite std:: avant cout, cin...
int main() {
   int i;
   cout << "Enter your favorite number:\n"; // Écriture
   cin >> i;                                // Lecture
   cout << "Number: " << i << "\n";         // Format
   cerr << "An error message" << endl; }    // Stderr
\end{cppcode}

\section*{Chaînes de caractère}

\begin{cppcode}
#include <string>

string a = "Hello", b = "World";
cout << a + " " + b; // "Hello World"
cout << a + " You"; // "Hello You"
a.append(" Dog"); // En C++ les chaînes sont modifiables

\end{cppcode}

    \section*{Références}

    \begin{cppcode}
string foo = "foo";
string& fooRef = foo;    // Référence sur foo
fooRef += "bar";         // Modifie foo via la référence
cout << foo;             // Affiche "foobar"
cout << &fooRef << endl; // Affiche l'adresse de foo
fooRef = string("bar");  // Copie de la valeur dans foo

const string& cbarRef = foo;
cbarRef += ". Hi!";       // Erreur ! cbarRef est const

string str;
void func(string& s) { ... }  // Référence standard
void func(string&& s) { ... } // Référence temporaire
func(str); // Référence standard
func(foo()); // Référence temporaire
\end{cppcode}

\section*{Flux}
\begin{cppcode}
double x = 3.141592;
cout << std::fixed; // Format décimal fixe
cout.precision(2);  // 2 chiffres après la virgule
cout << x << endl;  // Affiche 3.14
cout << std::scientific; // Format scientifique (3.14e+00)
cout << std::setw(5) << std::setprecision(3) << x; // comme "%+5.3f"
cout << "\n" << std::endl; // préférez \n, endl flush le flux
\end{cppcode}

\section*{Enumérations}

\begin{cppcode}
// Enumérations non typées
enum AnimalTypes { Mammals, Birds, Reptiles, Fish };
AnimalTypes GetAnimalType() { return Reptiles; }

// Enumérations typées (cast implicite en uint_8)
enum Amphibians : uint8_t { Frogs, Toads=2 };

// Enum fortement typées (pas de cast implicite)
enum class Birds : uint8_t { Chickens, Ducks };
\end{cppcode}

\section*{Templates}

\begin{cppcode}
template <class T> T f(T t);  // Template à 1 paramètre T
template <class T> class X {  // Classe avec paramètre T
   X(T t); };                 // Constructeur
template <class T>
   X<T>::X(T t) {}            // Impl. du constructeur
X<int> x{3};                  // Un objet de type X de int
template <class T, class U=T> // Valeurs par défaut

Box<Box<int> > boxOfBox;  // Template imbriquées
                          // Espace après > requis en C++03

template<int Y=23> void p() { // Paramètre scalaire
   cout << "You said " << Y; }// Affiche "You said 23"

template<>                    // Spécialisation
void p<42>() {                // (implémentation spécifique
   cout << "The Answer!\n"; } //  pour la valeur 42)
p<12>(); // You said 12
p<42>(); // The Answer!
\end{cppcode}

    \section*{Namespaces}

    \begin{cppcode}
extern "C" { void f(); }    // Si f() compilé dans un obj C
namespace N { class T {}; } // Cache la classe T dans N
N::T t;                     // Accès avec opérateur ::
using namespace N;          // Rend T visible sans préfix
using namespace std;        // Pour éviter std::xxx
\end{cppcode}

\section*{Classes}
\begin{cppcode}
struct S { int x; }; // Membres public par défaut
class  C { int x; }; // Membres privé par défaut

class Foo; // Déclaration anticipée

// Membres par défaut
struct A {
  A();                    // 1. Constructeur par défaut
  A(const A&);            // 2. Constructeur de copie
  A& operator=(const A&); // 3. Opérateur d'assignation
  A(A&&);                 // 4. Constructeur de déplacement
  A& operator=(A&&);      // 5. Opérateur de déplacement
  ~A();                   // 6. Destructeur
}; // Point virgule obligatoire

// Rule-of-zero:
// préférer le cas d'utiliser toutes définitions par défaut
// Rule-of-three:
// toujours définir 2, 3, 6 si une des 3 est définie
// Rule-of-five:
// toujours définir 2, 3, 4, 5, 6 si une des 5 est définie

class Dog {
    std::string name; // Privé par défaut (private:)
    int weight = 0; // Initialisation par défaut (C++11)
    mutable int age = 0; // Modifiable même si const
    std::vector<std::string> nicknames;
public:
    Dog(); // Constructeur par défaut

    // Constructeur avec members initializer list
    Dog(std::string n, int w=0) : name{n}, weight(w) {}

    // Constructeur avec liste d'initialisation
    Dog(std::initializer_list<std::string> nicks)
        : nicknames(nicks), age(0) {}

    void setName(const std::string& dogsName);
    void setWeight(int dogsWeight);

    void print() const; // const: ne modifie pas l'objet

    // Méthode définie dans le body d'une classe
    void bark() const { std::cout << name << " barks!" << endl; }

}; // Ne pas oublier le point-virgule!

// Implémentation externe des méthodes
Dog::Dog() {
    std::cout << "A dog has been constructed\n";
}

class C {
    C() = default; // Constructeur par défaut
    C(const C&) = delete; // Interdit la copie
    virtual ~C() = default; // Destructeur virtuel
    void f() const; // Méthode constante
    void f() noexcept; // Ne lance pas d'exception
    static int count; // Attribut statique (partagé)
    static int getCount(); // Méthode statique
};
\end{cppcode}

\section*{Interfaces}
\begin{cppcode}
// Interface = uniquement des méthodes virtuelles pures
class Shape {
    // Normalement pas d'attributs dans une interface
    virtual double area() const = 0;
    virtual ~Shape() = default;
};
\end{cppcode}

\section*{Héritage et polymorphisme}
\begin{cppcode}
class Triangle : public Shape { // Héritage public
    double base, height;
public:
    Triangle(double b, double h)
        : base(b), height(h) {}
    double area() const override { // Override
        return 0.5 * base * height; }
};
class Bar : public Foo {
    using Foo::Foo; }; // Hérite des constructeurs

void D::m() const {
    C::m(); } // Appel de la méthode du parent
\end{cppcode}

\section*{Polymorphisme}

\begin{cppcode}
// Surcharge d'opérateurs
T operator+(T x, T y);  // Surcharge +
T operator-(T x);       // Surcharge -x
T operator++(int);      // Surcharge x++ (postfixe)
T& operator++();        // Surcharge ++x (préfixe)
auto operator<=>(const P&) const = default;  // C++20 spaceship

// Opérateurs de comparaison
bool operator==(const T& other) const;
bool operator!=(const T& other) const;
bool operator<(const T& other) const;

// Opérateurs d'accès
T& operator[](size_t index);              // Accès par index
const T& operator[](size_t index) const;
T& operator*();                           // Déréférencement
T* operator->();                          // Accès membre

// Opérateurs d'assignation
T& operator+=(const T& other);
T& operator-=(const T& other);
T& operator*=(const T& other);
T& operator/=(const T& other);

// Surcharge de flux
template <class T>
std::ostream& operator<<(std::ostream& os, const T& t) {
    os << t.member; return os; }
\end{cppcode}

\section*{Exceptions}

\begin{cppcode}
#include <exception>
#include <stdexcept>

try {
   throw std::runtime_error("A problem occured"); }
catch (const std::exception& ex) {
   std::cout << ex.what(); }
catch (...) {
   std::cout << "Unknown exception caught";
   throw; } // Relève l'exception

// Hiérarchie d'exceptions standard
// std::exception
//   ├── std::logic_error
//   │   ├── std::invalid_argument
//   │   ├── std::domain_error
//   │   ├── std::length_error
//   │   └── std::out_of_range
//   └── std::runtime_error
//       ├── std::range_error
//       ├── std::overflow_error
//       └── std::underflow_error

// Spécification noexcept
void safe_function() noexcept;          // Ne lance jamais
void conditional() noexcept(condition); // Conditionnel
\end{cppcode}

\section*{Conteneurs de données}

\subsection*{Vector}
Tableau dynamique: capacité augmente de façon amortie (impl.-dépendant).
\begin{cppcode}
#include <vector>

vector<string> v;
v.push_back("item"); // Ajoute à la fin
v.back();        // Dernier élément
v.pop_back();    // Enlève à la fin
v.front();       // Premier élément
v[0];            // Accès direct (non sécurisé)
v.at(1);         // Accès sécurisé (vérifie les bornes)
v.clear();       // Vide le vecteur
v.insert(v.end(), 42); // Insertion à la fin O(1)
v.insert(v.begin(), 42); // Insertion au début O(n)
v.erase(v.begin()); // Efface une position O(n)
v.erase(v.begin(), v.begin() + 2); // Efface un intervalle O(n)
v.empty() // Vrai si vide
v.size()  // Nombre d'éléments

vector<int> w(10, 42); // 10 éléments initialisés à 42
v.reserve(100); // Réserve de la place pour 100 éléments
v.resize(50);  // Redimensionne à 50 éléments (ajoute des zéros)

// Pour stocker des références
std::vector<std::reference_wrapper<int>> v;
int a=1, b=2; v.push_back(a); v.push_back(b);
\end{cppcode}

\subsection*{Tuples (Liste non-modifiable)}

\begin{cppcode}
#include <tuple>

tuple<int, char> x = make_tuple(10, 'A'); // auto accepté

get<0>(x) = 20; // Modifie le premier élément
char w = get<1>(x); // Copie le deuxième élément

int i, c;
tie(i, c) = x; // Unpacking

tuple<int, char, double> z(11, 'A', 3.1415);
auto size = tuple_size<decltype(z)>::value;

auto concatenated = tuple_cat(x, z);
\end{cppcode}

\subsection*{Map (Association clé-valeur)}
Unordered map implémenté avec une table de hachage (O(1))\\
Map implémenté avec un arbre binaire équilibré (log n)
\begin{cppcode}
#include <map>

map<char, int> m;
m.insert(pair<char,int>('A', 1)); // m['A'] = 1; possible
m.insert(pair<char,int>('Z', 26));

map<char, int>::iterator it; // Itérateur
for (it=m.begin(); it!=m.end(); ++it)
    std::cout << it->first << "->" << it->second << ', ';

it = m.find('Z');
cout << it->second; // Affiche 26

#include <unordered_map>
unordered_map<char, int> um;
um['A'] = 1; um['Z'] = 26;
\end{cppcode}

\subsection*{Set (Ensemble de valeurs uniques)}

\begin{cppcode}
#include <set>
set<int> s;
s.insert(4);
s.insert(15);
s.erase(8);

set<int>::iterator it;
for(it=s.begin(); it!=s.end(); it++) {
    cout << *it << endl; }
s.clear();
cout << s.size(); // Affiche zéro
\end{cppcode}

\subsection*{Autres conteneurs STL}

\begin{cppcode}
// Deque (double-ended queue)
#include <deque>
std::deque<int> dq{1, 2, 3};
dq.push_front(0); dq.push_back(4); // Insertion aux deux bouts O(1)

// List (liste doublement chaînée)
#include <list>
std::list<int> lst{1, 3, 5};
lst.insert(++lst.begin(), 2); // Insertion O(1) si on a l'itérateur

// Stack (pile LIFO)
#include <stack>
std::stack<int> stk;
stk.push(1); stk.push(2);
int top = stk.top(); stk.pop(); // top = 2

// Queue (file FIFO)
#include <queue>
std::queue<int> q;
q.push(1); q.push(2);
int front = q.front(); q.pop(); // front = 1

// Priority queue (tas)
#include <queue>
std::priority_queue<int> pq; // Max-heap par défaut
pq.push(3); pq.push(1); pq.push(4);
int max = pq.top(); pq.pop(); // max = 4
\end{cppcode}

\section*{Algorithmes STL essentiels}

\begin{cppcode}
#include <algorithm>
#include <numeric>

std::vector<int> v{3, 1, 4, 1, 5};

std::sort(v.begin(), v.end()); // Tri croissant
std::reverse(v.begin(), v.end()); // Tri décroissant

// Recherche
auto it = std::find(v.begin(), v.end(), 4);
bool found = (it != v.end());

// Transformation
std::vector<int> v2(v.size());
std::transform(v.begin(), v.end(), v2.begin(),
               [](int x) { return x * 2; });

// Réduction
// Type retour celui de valeur initiale (ici int)
auto sum = std::accumulate(v.begin(), v.end(), 0);

// Filtrage (C++20 style avec remove_if)
v.erase(std::remove_if(v.begin(), v.end(),
                       [](int x) { return x % 2 == 0; }),
        v.end());

// Autres algorithmes utiles
auto min_it = std::min_element(v.begin(), v.end());
auto max_it = std::max_element(v.begin(), v.end());
std::swap(*min_it, *max_it);

bool all_positive = std::all_of(v.begin(), v.end(),
                                [](int x) { return x > 0; });
bool any_negative = std::any_of(v.begin(), v.end(),
                                [](int x) { return x < 0; });

std::vector<int> v3;
std::copy_if(v.begin(), v.end(), std::back_inserter(v3),
             [](int x) { return x % 2 == 0; }); // Copie conditionnelle
\end{cppcode}

\section*{Fonctions anonymes (lambda)}

\begin{cppcode}

vector<pair<int, int> > v{{1,2}, {3,4}, {5,6}};
sort(
    v.begin(), v.end(),
    [](const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second < rhs.second; });

// Format: [captures](params) -> ret { body }
int x = 5; int y = 10;
auto g = [x, &y](int z) -> int { return x + y++ + z; };

// Formats de capture
[&]{}; [=]{}; // 1. Tout par référence, 2. tout par valeur
[&, i]{}; // Scope local par référence, i par valeur
[&, &i]{}; // Erreur, incohérent
[this]{};   // Cette instance par référence
[*this]{}; // Cette instance par valeur (copie)
\end{cppcode}

\section*{Tokens alternatifs}
\begin{cppcode}
true and false     // Conjonction logique
true or false      // Disjonction logique
not true           // Négation logique
compl 4            // Complément bit à bit
4 bitor 3          // Disjonction bit à bit
4 bitand 3         // Conjonction bit à bit
4 xor 3            // Disjonction exclusive bit à bit
\end{cppcode}

\section*{Smart Pointer}
\begin{cppcode}
#include <memory>

std::shared_ptr<Dog> doggo(new Dog()); // Ancien style
auto doggo = std::make_shared<Dog>();  // Préféré
doggo->bark();
// Pas besoin de supprimer le Dog, destruction auto

// Propriété exclusive
std::unique_ptr<Dog> dog = std::make_unique<Dog>();
// Transfert de propriété
std::unique_ptr<Dog> dog2 = std::move(dog);

// Référence faible (évite cycles)
// Utilisé comme observateur non possédant
std::weak_ptr<Dog> weak_dog = doggo;
if (auto strong_dog = weak_dog.lock()) {
    strong_dog->bark(); // Utilisation sécurisée
}
\end{cppcode}

\section*{Casting et conversions}
\begin{cppcode}
// Casts C++ sécurisés (préférés aux casts C)
int i = 42;
double d = static_cast<double>(i);        // Conversion sûre

class Base {}; class Derived : public Base {};
Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);   // Cast avec vérification
if (d != nullptr) { /* succès */ }

// Conversion de pointeurs (dangereux)
void* ptr = &i;
int* iptr = reinterpret_cast<int*>(ptr);

// Enlever const (dangereux)
const int ci = 42;
int& ri = const_cast<int&>(ci);

// Cast C style (éviter)
double d2 = (double)i; // Préférer static_cast<double>(i)
\end{cppcode}

\section*{Constexpr}
\begin{cppcode}
    // constexpr - évaluation à la compilation
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
constexpr int result = factorial(5); // Calculé à la compilation
\end{cppcode}

\section*{Gestion mémoire et RAII}
\begin{cppcode}
// RAII (Resource Acquisition Is Initialization)
class FileHandler {
    FILE* file;
public:
    FileHandler(const char* name) : file(fopen(name, "r")) {
        if (!file) throw std::runtime_error("Cannot open file");
    }
    ~FileHandler() { if (file) fclose(file); } // Cleanup automatique
    FILE* get() { return file; }
};

// Allocation/désallocation manuelle (éviter si possible)
int* ptr = new int(42);        // Allocation
delete ptr;                    // Désallocation
int* arr = new int[10];        // Tableau
delete[] arr;                  // Désallocation tableau

// Préférer les containers et smart pointers
std::vector<int> v(10, 42);    // Gestion automatique
auto ptr = std::make_unique<int>(42); // Smart pointer
\end{cppcode}

\section*{Move semantics}

\begin{cppcode}
std::vector<int> v1 = {1,2,3,4,5};
std::vector<int> v2 = v1; // Copie (lent)
std::vector<int> v3 = std::move(v1); // Transfert (rapide)

class C {
    using value_type = std::string;
    C(value_type s) : data(s) {}
    C(C&& other) noexcept
        : data(std::move(other.data)) {}
    C& operator=(C&& other) noexcept {
        data = std::move(other.data);
        return *this; }
private:
    value_type data;
};
C a("X");
C b = std::move(a); // Construction par déplacement
b = std::move(a);   // Assignation par déplacement
\end{cppcode}

\section*{Ranges (C++20)}

\begin{cppcode}
// Inclure <ranges>, <vector>, <algorithm>, <iostream>
std::vector<int> v{1,2,3,4,5,6,7,8,9,10};

// Pipeline ranges: filtre puis transforme
auto rng = v
    | std::views::filter([](int x){ return x % 2 == 0; })
    | std::views::transform([](int x){ return x * x; });

for (int x : rng) std::cout << x << ' '; // 4 16 36 64 100

// Prise de tête zéro : lazy, pas de copies inutiles
// Raccourcis utiles:
auto first3 = rng | std::views::take(3);
auto rev    = rng | std::views::reverse;

// Conversion en conteneur:
std::vector<int> out;
std::ranges::copy(rng, std::back_inserter(out));
\end{cppcode}

\section*{Slices et Vues (C++20)}

\begin{cppcode}
#include <span>
#include <string_view>
#include <vector>

// std::span : vue non-propriétaire sur un bloc contigu
// (T[], vector<T>, array<T,N>) n'alloue pas,
// ne possède pas, "slice" sans copie.
void sum_all(std::span<const int> s) {
    long long sum = 0;
    for (int x : s) sum += x;
    /* ... */
}

std::vector<int> v{1,2,3,4,5};
sum_all(v);              // conversion implicite vers span
sum_all(std::span{v}.subspan(1,3)); // slice [2,3,4]

// std::string_view : vue en lecture seule sur une chaîne
void print_sv(std::string_view sv) { /* pas de copie */ }

std::string s = "hello world";
print_sv(s);
print_sv("abc");                  // littéral → string_view
print_sv(std::string_view{s}.substr(6, 5)); // "world"
\end{cppcode}

\section*{Traits et Concepts (C++20)}

\begin{cppcode}
// Inclure <type_traits>, <concepts>, <vector>, <list>

// Traits classiques (C++11/14/17)
static_assert(std::is_integral_v<int>);
static_assert(!std::is_pointer_v<int>);

// Concepts standards
template<std::integral T>
T add(T a, T b) { return a + b; }

// Concept personnalisé
template<typename T>
concept HasSize = requires(T t) {
    { t.size() } -> std::convertible_to<std::size_t>;
};

template<HasSize C>
auto size2(const C& c) { return c.size() * 2; }

static_assert(std::ranges::range<std::vector<int>>);
static_assert(!std::ranges::range<int>);
\end{cppcode}

\section*{Divers}

\begin{cppcode}
// C++17: structured bindings
auto [key, value] = std::make_pair("hello", 42);
std::map<std::string, int> m{{"a", 1}, {"b", 2}};
for (const auto& [k, v] : m) {
    std::cout << k << ": " << v << "\n";
}

// if constexpr (C++17) évaluation à la compilation
template<typename T>
void process(T value) {
    if constexpr (std::is_integral_v<T>) {
        // Code pour les entiers
    } else {
        // Code pour les autres types
    }
}

// Using declarations et alias
using std::cout, std::endl; // Import sélectif (C++17)
using vec_int = std::vector<int>; // Alias de type
template<typename T>
using vec = std::vector<T>; // Template alias

// Attribute (C++11/14/17/20)
[[nodiscard]] int important_function(); // Résultat à ne pas ignorer
[[maybe_unused]] int x = 42;           // Variable potentiellement inutilisée
[[deprecated("Use new_function()")]] void old_function();
[[fallthrough]]; // Dans un switch, chute intentionnelle
\end{cppcode}

\section*{Thread safety et concurrence}
\begin{cppcode}
#include <thread>
#include <mutex>
#include <atomic>

// Threads
std::thread t1([]{ std::cout << "Hello from thread\n"; });
t1.join(); // Attendre la fin du thread

// Mutex pour synchronisation
std::mutex mtx;
void safe_function() {
    std::lock_guard<std::mutex> lock(mtx); // RAII lock
    // Code thread-safe
}

// Atomic pour opérations atomiques
std::atomic<int> counter{0};
counter++; // Thread-safe

// std::condition_variable pour synchronisation avancée
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; }); // Attendre signal
    // Travail...
}

void notifier() {
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
    }
    cv.notify_one(); // Réveiller un thread
}

// std::future pour résultats asynchrones
std::future<int> result = std::async(std::launch::async, [](){
    return 42;
});
int value = result.get(); // Récupérer le résultat
\end{cppcode}

\section*{Debug et assertions}
\begin{cppcode}
#include <cassert>

// Assertions (désactivées avec NDEBUG)
assert(x > 0); // Vérification en debug uniquement

// static_assert (vérification à la compilation)
static_assert(sizeof(int) == 4, "int doit faire 4 bytes");
static_assert(std::is_integral_v<int>);

// Compilation conditionnelle
#ifdef DEBUG
    std::cout << "Debug info: " << x << std::endl;
#endif

#ifndef NDEBUG
    // Code de debug
    std::cerr << "Debug: variable = " << var << std::endl;
#endif
\end{cppcode}

\section*{Utilitaires modernes}

\begin{cppcode}
// <optional> (C++17)
std::optional<int> parse_int(std::string_view s);
if (auto v = parse_int("42")) { /* v.value() */ }

// <variant> (somme de types)
std::variant<int, std::string> u = 42;
u = std::string{"hi"};

// <filesystem> (C++17)
namespace fs = std::filesystem;
for (auto& p : fs::directory_iterator(".")) {
    if (p.is_regular_file()) std::cout << p.path() << '\n';
}

// <chrono> (durées & time points)
using namespace std::chrono_literals;
auto t = 150ms + 2s;

// <format> (C++20) <print> (C++23)
std::string s = std::format("Hello {}, value = {}", "world", 42);
std::print("Pi ~ {:.3f}\n", 3.14159); // C++23

// <expected> (C++23) - gestion d'erreurs sans exceptions
std::expected<int, std::string> divide(int a, int b) {
    if (b == 0) return std::unexpected("Division by zero");
    return a / b;
}
auto result = divide(10, 2);
if (result) std::cout << *result; // 5
else std::cout << result.error(); // message d'erreur

// Modules (C++20)
// export module math;
// export int add(int a, int b) { return a + b; }
// import math; // dans un autre fichier

// Coroutines (C++20) - exemple simple
std::generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        auto next = a + b;
        a = b; b = next;
    }
}
\end{cppcode}

\section*{Littéraux et suffixes}
\begin{cppcode}
// Littéraux numériques
auto i = 42;        // int
auto l = 42L;       // long
auto ll = 42LL;     // long long
auto u = 42U;       // unsigned
auto f = 3.14f;     // float
auto d = 3.14;      // double (défaut)
auto ld = 3.14L;    // long double

// Bases numériques
auto bin = 0b1010;  // Binaire (C++14)
auto oct = 0755;    // Octal
auto hex = 0xDEAD;  // Hexadécimal

// Séparateurs (C++14)
auto big = 1'000'000; // 1000000

// Chaînes littérales
auto s1 = "Hello";     // const char*
auto s2 = "Hello"s;    // std::string (C++14)
auto sv = "Hello"sv;   // std::string_view (C++17)

// Raw strings
auto raw = R"(Path: C:\Users\Name\File.txt)";
auto multiline = R"delimiter(
    Texte sur
    plusieurs lignes
)delimiter";
\end{cppcode}

\section*{Préprocesseur}
\begin{cppcode}
// Macros essentielles
#define MAX(a,b) ((a)>(b)?(a):(b))  // Éviter, préférer template
#define SQUARE(x) ((x)*(x))         // Problème: SQUARE(++i)

// Macros utiles
#ifdef DEBUG
#define DBG(x) std::cout << #x " = " << (x) << std::endl
#else
#define DBG(x)
#endif

// Concaténation
#define CONCAT(a,b) a##b
int CONCAT(var, 42) = 10; // int var42 = 10;

// Stringification
#define STRINGIFY(x) #x
const char* name = STRINGIFY(variable); // "variable"
\end{cppcode}

\section*{Étrangetés}

\begin{cppcode}
// Surcharge de méthode privées
class Foo {
private:
   virtual void bar();
};
class FooSub : public Foo {
   virtual void bar() override;      // Surcharge Foo::bar!
};

assert(0 == false and false == nullptr); // La plupart du temps
\end{cppcode}

\section*{Optimisation}
\begin{cppcode}
// Objets temporaires
string foo() { return string("foo"); }
string retVal = foo(); // Choix selon optimisation:
// 1. Copie inutile d'un objet temporaire (< C++11)
// 2. Copy elision, suppression de la copie (C++17)
// 3. Utilisation de move semantics si disponible

return std::string("hello") // RVO (Return Value Optim.)
return result; // NRVO (Named Return Value Optimization)

// Conseils de performance
// 1. Préférer ++i à i++ pour les itérateurs
for (auto it = v.begin(); it != v.end(); ++it) { /* ... */ }

// 2. Utiliser const& pour éviter les copies
void process(const std::vector<int>& v); // Pas de copie

// 3. Réserver la mémoire si taille connue
std::vector<int> v;
v.reserve(1000); // Évite les réallocations

// 4. Utiliser emplace au lieu de push
v.emplace_back(args...); // Construction in-place
// au lieu de v.push_back(Type(args...));

// 5. Move pour les ressources coûteuses
std::vector<int> v1 = create_big_vector();
std::vector<int> v2 = std::move(v1); // Pas de copie
\end{cppcode}

\section*{S.O.L.I.D.}
\begin{description}
    \item[S] Single responsibility principle
    \item[O] Open for extension, closed for modification
    \item[L] Liskov substition principle
    \item[I] Interface segregation principle
    \item[D] Dependency inversion principle
\end{description}

\end{multicols*}
\end{document}
